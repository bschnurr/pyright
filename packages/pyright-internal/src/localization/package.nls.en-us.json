{
  "Diagnostic.abstractMethodInvocation": "Method \"{method}\" cannot be called because it is abstract",
  "Diagnostic.annotatedParamCountMismatch": "Parameter annotation count mismatch: expected {expected} but received {received}",
  "Diagnostic.annotatedTypeArgMissing": "Expected one type argument and one or more annotations for \"Annotated\"",
  "Diagnostic.annotationFormatString": "Type annotations cannot use format string literals (f-strings)",
  "Diagnostic.annotationNotSupported": "Type annotation not supported for this statement",
  "Diagnostic.annotationSpansStrings": "Type annotations cannot span multiple string literals",
  "Diagnostic.annotationStringEscape": "Type annotations cannot contain escape characters",
  "Diagnostic.argAssignment": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\"",
  "Diagnostic.argAssignmentFunction": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\" in function \"{functionName}\"",
  "Diagnostic.argAssignmentParam": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\"",
  "Diagnostic.argAssignmentParamFunction": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\" in function \"{functionName}\"",
  "Diagnostic.argMissingForParam": "Argument missing for parameter {name}",
  "Diagnostic.argMissingForParams": "Arguments missing for parameters {names}",
  "Diagnostic.argMorePositionalExpectedCount": "Expected {expected} more positional arguments",
  "Diagnostic.argMorePositionalExpectedOne": "Expected 1 more positional argument",
  "Diagnostic.argPositional": "Expected positional argument",
  "Diagnostic.argPositionalExpectedCount": "Expected {expected} positional arguments",
  "Diagnostic.argPositionalExpectedOne": "Expected 1 positional argument",
  "Diagnostic.argTypePartiallyUnknown": "Argument type is partially unknown",
  "Diagnostic.argTypeUnknown": "Argument type is unknown",
  "Diagnostic.assertAlwaysTrue": "Assert expression always evaluates to true",
  "Diagnostic.assertTypeArgs": "\"assert_type\" expects two positional arguments",
  "Diagnostic.assertTypeTypeMismatch": "\"assert_type\" mismatch: expected \"{expected}\" but received \"{received}\"",
  "Diagnostic.assignmentExprContext": "Assignment expression must be within module, function or lambda",
  "Diagnostic.assignmentExprComprehension": "Assignment expression target \"{name}\" cannot use same name as comprehension for target",
  "Diagnostic.assignmentInProtocol": "Instance or class variables within a Protocol class must be explicitly declared within the class body",
  "Diagnostic.assignmentExprInSubscript": "Assignment expressions within a subscript are supported only in Python 3.10 and newer",
  "Diagnostic.assignmentTargetExpr": "Expression cannot be assignment target",
  "Diagnostic.asyncNotInAsyncFunction": "Use of \"async\" not allowed outside of async function",
  "Diagnostic.awaitIllegal": "Use of \"await\" requires Python 3.5 or newer",
  "Diagnostic.awaitNotInAsync": "\"await\" allowed only within async function",
  "Diagnostic.backticksIllegal": "Expressions surrounded by backticks are not supported in Python 3.x; use repr instead",
  "Diagnostic.baseClassCircular": "Class cannot derive from itself",
  "Diagnostic.baseClassFinal": "Base class \"{type}\" is marked final and cannot be subclassed",
  "Diagnostic.baseClassInvalid": "Argument to class must be a base class",
  "Diagnostic.baseClassMethodTypeIncompatible": "Base classes for class \"{classType}\" define method \"{name}\" in incompatible way",
  "Diagnostic.baseClassVariableTypeIncompatible": "Base classes for class \"{classType}\" define variable \"{name}\" in incompatible way",
  "Diagnostic.baseClassUnknown": "Base class type is unknown, obscuring type of derived class",
  "Diagnostic.bindTypeMismatch": "Could not bind method \"{methodName}\" because \"{type}\" is not assignable to parameter \"{paramName}\"",
  "Diagnostic.breakOutsideLoop": "\"break\" can be used only within a loop",
  "Diagnostic.callableExtraArgs": "Expected only two type arguments to \"Callable\"",
  "Diagnostic.callableFirstArg": "Expected parameter type list or \"...\"",
  "Diagnostic.callableNotInstantiable": "Cannot instantiate type \"{type}\"",
  "Diagnostic.callableSecondArg": "Expected return type as second type argument for \"Callable\"",
  "Diagnostic.casePatternIsIrrefutable": "Irrefutable pattern is allowed only for the last case statement",
  "Diagnostic.classAlreadySpecialized": "Type \"{type}\" is already specialized",
  "Diagnostic.classDecoratorTypeUnknown": "Untyped class decorator obscures type of class; ignoring decorator",
  "Diagnostic.classDefinitionCycle": "Class definition for \"{name}\" depends on itself",
  "Diagnostic.classGetItemClsParam": "__class_getitem__ override should take a \"cls\" parameter",
  "Diagnostic.classMethodClsParam": "Class methods should take a \"cls\" parameter",
  "Diagnostic.classNotRuntimeSubscriptable": "Subscript for class \"{name}\" will generate runtime exception; enclose type annotation in quotes",
  "Diagnostic.classPatternBuiltInArgCount": "Class pattern accepts at most 1 positional sub-pattern",
  "Diagnostic.classPatternBuiltInArgPositional": "Class pattern accepts only positional sub-pattern",
  "Diagnostic.classPatternTypeAlias": "\"{type}\" cannot be used in a class pattern because it is a specialized type alias",
  "Diagnostic.classTypeParametersIllegal": "Class type parameter syntax requires Python 3.12 or newer",
  "Diagnostic.classVarNotAllowed": "\"ClassVar\" is not allowed in this context",
  "Diagnostic.classVarFirstArgMissing": "Expected a type argument after \"ClassVar\"",
  "Diagnostic.classVarOverridesInstanceVar": "Class variable \"{name}\" overrides instance variable of same name in class \"{className}\"",
  "Diagnostic.classVarTooManyArgs": "Expected only one type argument after \"ClassVar\"",
  "Diagnostic.classVarWithTypeVar": "\"ClassVar\" type cannot include type variables",
  "Diagnostic.clsSelfParamTypeMismatch": "Type of parameter \"{name}\" must be a supertype of its class \"{classType}\"",
  "Diagnostic.codeTooComplexToAnalyze": "Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths",
  "Diagnostic.collectionAliasInstantiation": "Type \"{type}\" cannot be instantiated, use \"{alias}\" instead",
  "Diagnostic.comparisonAlwaysFalse": "Condition will always evaluate to False since the types \"{leftType}\" and \"{rightType}\" have no overlap",
  "Diagnostic.comparisonAlwaysTrue": "Condition will always evaluate to True since the types \"{leftType}\" and \"{rightType}\" have no overlap",
  "Diagnostic.comprehensionInDict": "Comprehension cannot be used with other dictionary entries",
  "Diagnostic.comprehensionInSet": "Comprehension cannot be used with other set entries",
  "Diagnostic.concatenateParamSpecMissing": "Last type argument for \"Concatenate\" must be a ParamSpec",
  "Diagnostic.concatenateTypeArgsMissing": "\"Concatenate\" requires at least two type arguments",
  "Diagnostic.conditionalOperandInvalid": "Invalid conditional operand of type \"{type}\"",
  "Diagnostic.constantRedefinition": "\"{name}\" is constant (because it is uppercase) and cannot be redefined",
  "Diagnostic.constructorParametersMismatch": "Mismatch between signature of __new__ and __init__ in class \"{classType}\"",
  "Diagnostic.containmentAlwaysFalse": "Expression will always evaluate to False since the types \"{leftType}\" and \"{rightType}\" have no overlap",
  "Diagnostic.containmentAlwaysTrue": "Expression will always evaluate to True since the types \"{leftType}\" and \"{rightType}\" have no overlap",
  "Diagnostic.continueInFinally": "\"continue\" cannot be used within a finally clause",
  "Diagnostic.continueOutsideLoop": "\"continue\" can be used only within a loop",
  "Diagnostic.constructorNoArgs": "Expected no arguments to \"{type}\" constructor",
  "Diagnostic.dataClassBaseClassFrozen": "A non-frozen class cannot inherit from a class that is frozen",
  "Diagnostic.dataClassBaseClassNotFrozen": "A frozen class cannot inherit from a class that is not frozen",
  "Diagnostic.dataClassConverterFunction": "Argument of type \"{argType}\" is not a valid converter for field \"{fieldName}\" of type \"{fieldType}\"",
  "Diagnostic.dataClassConverterOverloads": "No overloads of \"{funcName}\" are valid converters for field \"{fieldName}\" of type \"{fieldType}\"",
  "Diagnostic.dataClassFieldWithDefault": "Fields without default values cannot appear after fields with default values",
  "Diagnostic.dataClassFieldWithoutAnnotation": "Dataclass field without type annotation will cause runtime exception",
  "Diagnostic.dataClassFieldWithPrivateName": "Dataclass field cannot use private name",
  "Diagnostic.dataClassPostInitParamCount": "Dataclass __post_init__ incorrect parameter count; number of InitVar fields is {expected}",
  "Diagnostic.dataClassPostInitType": "Dataclass __post_init__ method parameter type mismatch for field \"{fieldName}\"",
  "Diagnostic.dataClassSlotsOverwrite": "__slots__ is already defined in class",
  "Diagnostic.dataClassTransformExpectedBoolLiteral": "Expected expression that statically evaluates to True or False",
  "Diagnostic.dataClassTransformFieldSpecifier": "Expected tuple of classes or functions but received type \"{type}\"",
  "Diagnostic.dataClassTransformPositionalParam": "All arguments to \"dataclass_transform\" must be keyword arguments",
  "Diagnostic.dataClassTransformUnknownArgument": "Argument \"{name}\" is not supported by dataclass_transform",
  "Diagnostic.declaredReturnTypePartiallyUnknown": "Declared return type, \"{returnType}\", is partially unknown",
  "Diagnostic.declaredReturnTypeUnknown": "Declared return type is unknown",
  "Diagnostic.defaultValueContainsCall": "Function calls and mutable objects not allowed within parameter default value expression",
  "Diagnostic.defaultValueNotAllowed": "Parameter with \"*\" or \"**\" cannot have default value",
  "Diagnostic.deprecatedClass": "The class \"{name}\" is deprecated",
  "Diagnostic.deprecatedConstructor": "The constructor for class \"{name}\" is deprecated",
  "Diagnostic.deprecatedFunction": "This function \"{name}\" is deprecated",
  "Diagnostic.deprecatedType": "This type is deprecated as of Python {version}; use \"{replacement}\" instead",
  "Diagnostic.delTargetExpr": "Expression cannot be deleted",
  "Diagnostic.dictExpandIllegalInComprehension": "Dictionary expansion not allowed in comprehension",
  "Diagnostic.dictInAnnotation": "Dictionary expression not allowed in type annotation",
  "Diagnostic.dictKeyValuePairs": "Dictionary entries must contain key/value pairs",
  "Diagnostic.dictUnpackIsNotMapping": "Expected mapping for dictionary unpack operator",
  "Diagnostic.dunderAllSymbolNotPresent": "\"{name}\" is specified in __all__ but is not present in module",
  "Diagnostic.duplicateArgsParam": "Only one \"*\" parameter allowed",
  "Diagnostic.duplicateBaseClass": "Duplicate base class not allowed",
  "Diagnostic.duplicateCatchAll": "Only one catch-all except clause allowed",
  "Diagnostic.duplicateEnumMember": "Enum member \"{name}\" is already declared",
  "Diagnostic.duplicateGenericAndProtocolBase": "Only one Generic[...] or Protocol[...] base class allowed",
  "Diagnostic.duplicateImport": "\"{importName}\" is imported more than once",
  "Diagnostic.duplicateKwargsParam": "Only one \"**\" parameter allowed",
  "Diagnostic.duplicateKeywordOnly": "Only one \"*\" separator allowed",
  "Diagnostic.duplicateParam": "Duplicate parameter \"{name}\"",
  "Diagnostic.duplicateCapturePatternTarget": "Capture target \"{name}\" cannot appear more than once within the same pattern",
  "Diagnostic.duplicateStarPattern": "Only one \"*\" pattern allowed in a pattern sequence",
  "Diagnostic.duplicateStarStarPattern": "Only one \"**\" entry allowed",
  "Diagnostic.duplicatePositionOnly": "Only one \"/\" parameter allowed",
  "Diagnostic.duplicateUnpack": "Only one unpack operation allowed in list",
  "Diagnostic.ellipsisContext": "\"...\" not allowed in this context",
  "Diagnostic.ellipsisSecondArg": "\"...\" allowed only as the second of two arguments",
  "Diagnostic.enumClassOverride": "Enum class \"{name}\" is final and cannot be subclassed",
  "Diagnostic.exceptionGroupIncompatible": "Exception group syntax (\"except*\") requires Python 3.11 or newer",
  "Diagnostic.exceptionTypeIncorrect": "\"{type}\" does not derive from BaseException",
  "Diagnostic.exceptionTypeNotClass": "\"{type}\" is not a valid exception class",
  "Diagnostic.exceptionTypeNotInstantiable": "Constructor for exception type \"{type}\" requires one or more arguments",
  "Diagnostic.expectedAfterDecorator": "Expected function or class declaration after decorator",
  "Diagnostic.expectedArrow": "Expected \"->\" followed by return type annotation",
  "Diagnostic.expectedAsAfterException": "Expected \"as\" after exception type",
  "Diagnostic.expectedAssignRightHandExpr": "Expected expression to the right of \"=\"",
  "Diagnostic.expectedBinaryRightHandExpr": "Expected expression to the right of operator",
  "Diagnostic.expectedBoolLiteral": "Expected True or False",
  "Diagnostic.expectedCase": "Expected \"case\" statement",
  "Diagnostic.expectedClassName": "Expected class name",
  "Diagnostic.expectedCloseBrace": "\"{\" was not closed",
  "Diagnostic.expectedCloseBracket": "\"[\" was not closed",
  "Diagnostic.expectedCloseParen": "\"(\" was not closed",
  "Diagnostic.expectedColon": "Expected \":\"",
  "Diagnostic.expectedComplexNumberLiteral": "Expected complex number literal for pattern matching",
  "Diagnostic.expectedDecoratorExpr": "Expression form not supported for decorator prior to Python 3.9",
  "Diagnostic.expectedDecoratorName": "Expected decorator name",
  "Diagnostic.expectedDecoratorNewline": "Expected new line at end of decorator",
  "Diagnostic.expectedDelExpr": "Expected expression after \"del\"",
  "Diagnostic.expectedElse": "Expected \"else\"",
  "Diagnostic.expectedEquals": "Expected \"=\"",
  "Diagnostic.expectedExceptionClass": "Invalid exception class or object",
  "Diagnostic.expectedExceptionObj": "Expected exception object, exception class or None",
  "Diagnostic.expectedExpr": "Expected expression",
  "Diagnostic.expectedIdentifier": "Expected identifier",
  "Diagnostic.expectedImport": "Expected \"import\"",
  "Diagnostic.expectedImportAlias": "Expected symbol after \"as\"",
  "Diagnostic.expectedImportSymbols": "Expected one or more symbol names after import",
  "Diagnostic.expectedIndentedBlock": "Expected indented block",
  "Diagnostic.expectedInExpr": "Expected expression after \"in\"",
  "Diagnostic.expectedIn": "Expected \"in\"",
  "Diagnostic.expectedFunctionAfterAsync": "Expected function definition after \"async\"",
  "Diagnostic.expectedFunctionName": "Expected function name after \"def\"",
  "Diagnostic.expectedMemberName": "Expected member name after \".\"",
  "Diagnostic.expectedModuleName": "Expected module name",
  "Diagnostic.expectedNameAfterAs": "Expected symbol name after \"as\"",
  "Diagnostic.expectedNamedParameter": "Keyword parameter must follow \"*\"",
  "Diagnostic.expectedNewline": "Expected newline",
  "Diagnostic.expectedNewlineOrSemicolon": "Statements must be separated by newlines or semicolons",
  "Diagnostic.expectedOpenParen": "Expected \"(\"",
  "Diagnostic.expectedParamName": "Expected parameter name",
  "Diagnostic.expectedPatternExpr": "Expected pattern expression",
  "Diagnostic.expectedPatternSubjectExpr": "Expected pattern subject expression",
  "Diagnostic.expectedPatternValue": "Expected pattern value expression of the form \"a.b\"",
  "Diagnostic.expectedReturnExpr": "Expected expression after \"return\"",
  "Diagnostic.expectedSliceIndex": "Expected index or slice expression",
  "Diagnostic.expectedTypeNotString": "Expected type but received a string literal",
  "Diagnostic.expectedTypeParameterName": "Expected type parameter name",
  "Diagnostic.expectedYieldExpr": "Expected expression in yield statement",
  "Diagnostic.finalClassIsAbstract": "Class \"{type}\" is marked final and must implement all abstract methods",
  "Diagnostic.finalContext": "\"Final\" not allowed in this context",
  "Diagnostic.finalMethodOverride": "Method \"{name}\" cannot override final method defined in class \"{className}\"",
  "Diagnostic.finalReassigned": "\"{name}\" is declared as Final and cannot be reassigned",
  "Diagnostic.finalRedeclaration": "\"{name}\" was previously declared as Final",
  "Diagnostic.finalRedeclarationBySubclass": "\"{name}\" cannot be redeclared because parent class \"{className}\" declares it as Final",
  "Diagnostic.finalTooManyArgs": "Expected a single type argument after \"Final\"",
  "Diagnostic.finalUnassigned": "\"{name}\" is declared Final, but value is not assigned",
  "Diagnostic.formatStringBrace": "Single close brace not allowed within f-string literal; use double close brace",
  "Diagnostic.formatStringBytes": "Format string literals (f-strings) cannot be binary",
  "Diagnostic.formatStringDebuggingIllegal": "F-string debugging specifier \"=\" requires Python 3.8 or newer",
  "Diagnostic.formatStringEscape": "Escape sequence (backslash) not allowed in expression portion of f-string prior to Python 3.12",
  "Diagnostic.formatStringExpectedConversion": "Expected a conversion specifier after \"!\" in f-string",
  "Diagnostic.formatStringInPattern": "Format string not allowed in pattern",
  "Diagnostic.formatStringNestedFormatSpecifier": "Expressions nested too deeply within format string specifier",
  "Diagnostic.formatStringNestedQuote": "Strings nested within an f-string cannot use the same quote character as the f-string prior to Python 3.12",
  "Diagnostic.formatStringUnicode": "Format string literals (f-strings) cannot be unicode",
  "Diagnostic.formatStringIllegal": "Format string literals (f-strings) require Python 3.6 or newer",
  "Diagnostic.formatStringUnterminated": "Unterminated expression in f-string; expecting \"}\"",
  "Diagnostic.functionDecoratorTypeUnknown": "Untyped function decorator obscures type of function; ignoring decorator",
  "Diagnostic.functionInConditionalExpression": "Conditional expression references function which always evaluates to True",
  "Diagnostic.functionTypeParametersIllegal": "Function type parameter syntax requires Python 3.12 or newer",
  "Diagnostic.futureImportLocationNotAllowed": "Imports from __future__ must be at the beginning of the file",
  "Diagnostic.generatorAsyncReturnType": "Return type of async generator function must be \"AsyncGenerator\" or \"AsyncIterable\"",
  "Diagnostic.generatorNotParenthesized": "Generator expressions must be parenthesized if not sole argument",
  "Diagnostic.generatorSyncReturnType": "Return type of generator function must be \"Generator\" or \"Iterable\"",
  "Diagnostic.genericBaseClassNotAllowed": "\"Generic\" base class cannot be used with type parameter syntax",
  "Diagnostic.genericClassAssigned": "Generic class type cannot be assigned",
  "Diagnostic.genericClassDeleted": "Generic class type cannot be deleted",
  "Diagnostic.genericNotAllowed": "\"Generic\" is not valid in this context",
  "Diagnostic.genericTypeAliasBoundTypeVar": "Generic type alias within class cannot use bound type variables {names}",
  "Diagnostic.genericTypeArgMissing": "\"Generic\" requires at least one type argument",
  "Diagnostic.genericTypeArgTypeVar": "Type argument for \"Generic\" must be a type variable",
  "Diagnostic.genericTypeArgUnique": "Type arguments for \"Generic\" must be unique",
  "Diagnostic.globalReassignment": "\"{name}\" is assigned before global declaration",
  "Diagnostic.globalRedefinition": "\"{name}\" was already declared global",
  "Diagnostic.implicitStringConcat": "Implicit string concatenation not allowed",
  "Diagnostic.importCycleDetected": "Cycle detected in import chain",
  "Diagnostic.importDepthExceeded": "Import chain depth exceeded {depth}",
  "Diagnostic.importResolveFailure": "Import \"{importName}\" could not be resolved",
  "Diagnostic.importSourceResolveFailure": "Import \"{importName}\" could not be resolved from source",
  "Diagnostic.importSymbolUnknown": "\"{name}\" is unknown import symbol",
  "Diagnostic.incompatibleMethodOverride": "Method \"{name}\" overrides class \"{className}\" in an incompatible manner",
  "Diagnostic.inconsistentIndent": "Unindent amount does not match previous indent",
  "Diagnostic.initMustReturnNone": "Return type of \"__init__\" must be None",
  "Diagnostic.inconsistentTabs": "Inconsistent use of tabs and spaces in indentation",
  "Diagnostic.initSubclassClsParam": "__init_subclass__ override should take a \"cls\" parameter",
  "Diagnostic.instanceMethodSelfParam": "Instance methods should take a \"self\" parameter",
  "Diagnostic.instanceVarOverridesClassVar": "Instance variable \"{name}\" overrides class variable of same name in class \"{className}\"",
  "Diagnostic.instantiateAbstract": "Cannot instantiate abstract class \"{type}\"",
  "Diagnostic.instantiateProtocol": "Cannot instantiate protocol class \"{type}\"",
  "Diagnostic.internalBindError": "An internal error occurred while binding file \"{file}\": {message}",
  "Diagnostic.internalParseError": "An internal error occurred while parsing file \"{file}\": {message}",
  "Diagnostic.internalTypeCheckingError": "An internal error occurred while type checking file \"{file}\": {message}",
  "Diagnostic.invalidIdentifierChar": "Invalid character in identifier",
  "Diagnostic.invalidStubStatement": "Statement is meaningless within a type stub file",
  "Diagnostic.invalidTokenChars": "Invalid character \"{text}\" in token",
  "Diagnostic.isInstanceInvalidType": "Second argument to \"isinstance\" must be a class or tuple of classes",
  "Diagnostic.isSubclassInvalidType": "Second argument to \"issubclass\" must be a class or tuple of classes",
  "Diagnostic.keyValueInSet": "Key/value pairs are not allowed within a set",
  "Diagnostic.keywordArgInTypeArgument": "Keyword arguments cannot be used in type argument lists",
  "Diagnostic.keywordOnlyAfterArgs": "Keyword-only argument separator not allowed after \"*\" parameter",
  "Diagnostic.keywordParameterMissing": "One or more keyword parameters must follow \"*\" parameter",
  "Diagnostic.keywordSubscriptIllegal": "Keyword arguments within subscripts are not supported",
  "Diagnostic.lambdaReturnTypeUnknown": "Return type of lambda is unknown",
  "Diagnostic.lambdaReturnTypePartiallyUnknown": "Return type of lambda, \"{returnType}\", is partially unknown",
  "Diagnostic.listAssignmentMismatch": "Expression with type \"{type}\" cannot be assigned to target list",
  "Diagnostic.listInAnnotation": "List expression not allowed in type annotation",
  "Diagnostic.literalUnsupportedType": "Type arguments for \"Literal\" must be None, a literal value (int, bool, str, or bytes), or an enum value",
  "Diagnostic.literalEmptyArgs": "Expected one or more type arguments after \"Literal\"",
  "Diagnostic.literalNotCallable": "Literal type cannot be instantiated",
  "Diagnostic.matchIncompatible": "Match statements require Python 3.10 or newer",
  "Diagnostic.matchIsNotExhaustive": "Cases within match statement do not exhaustively handle all values",
  "Diagnostic.maxParseDepthExceeded": "Maximum parse depth exceeded; break expression into smaller sub-expressions",
  "Diagnostic.memberAccess": "Cannot access member \"{name}\" for type \"{type}\"",
  "Diagnostic.memberDelete": "Cannot delete member \"{name}\" for type \"{type}\"",
  "Diagnostic.memberSet": "Cannot assign member \"{name}\" for type \"{type}\"",
  "Diagnostic.metaclassConflict": "The metaclass of a derived class must be a subclass of the metaclasses of all its base classes",
  "Diagnostic.metaclassDuplicate": "Only one metaclass can be provided",
  "Diagnostic.metaclassIsGeneric": "Metaclass cannot be generic",
  "Diagnostic.methodNotDefined": "\"{name}\" method not defined",
  "Diagnostic.methodNotDefinedOnType": "\"{name}\" method not defined on type \"{type}\"",
  "Diagnostic.methodOrdering": "Cannot create consistent method ordering",
  "Diagnostic.methodOverridden": "\"{name}\" overrides method of same name in class \"{className}\" with incompatible type \"{type}\"",
  "Diagnostic.methodReturnsNonObject": "\"{name}\" method does not return an object",
  "Diagnostic.missingProtocolMembers": "Class derives from one or more protocol classes but does not implement all required members",
  "Diagnostic.missingSuperCall": "Method \"{methodName}\" does not call the method of the same name in parent class",
  "Diagnostic.moduleAsType": "Module cannot be used as a type",
  "Diagnostic.moduleNotCallable": "Module is not callable",
  "Diagnostic.moduleUnknownMember": "\"{memberName}\" is not a known member of module \"{moduleName}\"",
  "Diagnostic.namedExceptAfterCatchAll": "A named except clause cannot appear after catch-all except clause",
  "Diagnostic.namedParamAfterParamSpecArgs": "Keyword parameter \"{name}\" cannot appear in signature after ParamSpec args parameter",
  "Diagnostic.namedTupleEmptyName": "Names within a named tuple cannot be empty",
  "Diagnostic.namedTupleMultipleInheritance": "Multiple inheritance with NamedTuple is not supported",
  "Diagnostic.namedTupleFirstArg": "Expected named tuple class name as first argument",
  "Diagnostic.namedTupleNameType": "Expected two-entry tuple specifying entry name and type",
  "Diagnostic.namedTupleNameUnique": "Names within a named tuple must be unique",
  "Diagnostic.namedTupleNoTypes": "\"namedtuple\" provides no types for tuple entries; use \"NamedTuple\" instead",
  "Diagnostic.namedTupleSecondArg": "Expected named tuple entry list as second argument",
  "Diagnostic.newClsParam": "__new__ override should take a \"cls\" parameter",
  "Diagnostic.newTypeBadName": "The first argument to NewType must be a string literal",
  "Diagnostic.newTypeLiteral": "NewType cannot be used with Literal type",
  "Diagnostic.newTypeNotAClass": "Expected class as second argument to NewType",
  "Diagnostic.newTypeParamCount": "NewType requires two positional arguments",
  "Diagnostic.newTypeProtocolClass": "NewType cannot be used with protocol class",
  "Diagnostic.nonDefaultAfterDefault": "Non-default argument follows default argument",
  "Diagnostic.noneNotCallable": "Object of type \"None\" cannot be called",
  "Diagnostic.noneNotIterable": "Object of type \"None\" cannot be used as iterable value",
  "Diagnostic.noneOperator": "Operator \"{operator}\" not supported for \"None\"",
  "Diagnostic.noneNotSubscriptable": "Object of type \"None\" is not subscriptable",
  "Diagnostic.noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
  "Diagnostic.noneUnknownMember": "\"{name}\" is not a known member of \"None\"",
  "Diagnostic.nonLocalNoBinding": "No binding for nonlocal \"{name}\" found",
  "Diagnostic.nonLocalReassignment": "\"{name}\" is assigned before nonlocal declaration",
  "Diagnostic.nonLocalRedefinition": "\"{name}\" was already declared nonlocal",
  "Diagnostic.nonLocalInModule": "Nonlocal declaration not allowed at module level",
  "Diagnostic.noOverload": "No overloads for \"{name}\" match the provided arguments",
  "Diagnostic.noReturnContainsReturn": "Function with declared return type \"NoReturn\" cannot include a return statement",
  "Diagnostic.noReturnContainsYield": "Function with declared return type \"NoReturn\" cannot include a yield statement",
  "Diagnostic.noReturnReturnsNone": "Function with declared type of \"NoReturn\" cannot return \"None\"",
  "Diagnostic.notRequiredArgCount": "Expected a single type argument after \"NotRequired\"",
  "Diagnostic.notRequiredNotInTypedDict": "\"NotRequired\" is not allowed in this context",
  "Diagnostic.objectNotCallable": "Object of type \"{type}\" is not callable",
  "Diagnostic.obscuredClassDeclaration": "Class declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.obscuredFunctionDeclaration": "Function declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.obscuredMethodDeclaration": "Method declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.obscuredParameterDeclaration": "Parameter declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.obscuredTypeAliasDeclaration": "Type alias declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.obscuredVariableDeclaration": "Declaration \"{name}\" is obscured by a declaration of the same name",
  "Diagnostic.operatorLessOrGreaterDeprecated": "Operator \"<>\" is not supported in Python 3; use \"!=\" instead",
  "Diagnostic.optionalExtraArgs": "Expected one type argument after \"Optional\"",
  "Diagnostic.orPatternIrrefutable": "Irrefutable pattern allowed only as the last subpattern in an \"or\" pattern",
  "Diagnostic.orPatternMissingName": "All subpatterns within an \"or\" pattern must target the same names",
  "Diagnostic.overlappingOverload": "Overload {obscured} for \"{name}\" will never be used because its parameters overlap overload {obscuredBy}",
  "Diagnostic.overloadAbstractMismatch": "Overloaded methods must all be abstract or not",
  "Diagnostic.overloadImplementationMismatch": "Overloaded implementation is not consistent with signature of overload {index}",
  "Diagnostic.overloadReturnTypeMismatch": "Overload {prevIndex} for \"{name}\" overlaps overload {newIndex} and returns an incompatible type",
  "Diagnostic.overloadWithImplementation": "\"{name}\" is marked as overload, but it includes an implementation",
  "Diagnostic.overloadWithoutImplementation": "\"{name}\" is marked as overload, but no implementation is provided",
  "Diagnostic.overriddenMethodNotFound": "Method \"{name}\" is marked as override, but no base method of same name is present",
  "Diagnostic.overrideDecoratorMissing": "Method \"{name}\" is not marked as override but is overriding a method in class \"{className}\"",
  "Diagnostic.paramAfterKwargsParam": "Parameter cannot follow \"**\" parameter",
  "Diagnostic.paramAlreadyAssigned": "Parameter \"{name}\" is already assigned",
  "Diagnostic.paramAnnotationMissing": "Type annotation is missing for parameter \"{name}\"",
  "Diagnostic.paramNameMissing": "No parameter named \"{name}\"",
  "Diagnostic.paramSpecArgsKwargsUsage": "\"args\" and \"kwargs\" members of ParamSpec must both appear within a function signature",
  "Diagnostic.paramSpecArgsMissing": "Arguments for ParamSpec \"{type}\" are missing",
  "Diagnostic.paramSpecArgsUsage": "\"args\" member of ParamSpec is valid only when used with *args parameter",
  "Diagnostic.paramSpecAssignedName": "ParamSpec must be assigned to a variable named \"{name}\"",
  "Diagnostic.paramSpecContext": "ParamSpec not allowed in this context",
  "Diagnostic.paramSpecDefaultNotTuple": "Expected ellipsis, a tuple expression, or ParamSpec for default value of ParamSpec",
  "Diagnostic.paramSpecFirstArg": "Expected name of ParamSpec as first argument",
  "Diagnostic.paramSpecKwargsUsage": "\"kwargs\" member of ParamSpec is valid only when used with **kwargs parameter",
  "Diagnostic.paramSpecNotBound": "Param spec \"{type}\" has no bound value",
  "Diagnostic.paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" has no meaning in this context",
  "Diagnostic.paramSpecScopedToReturnType": "ParamSpec \"{name}\" is scoped to a callable within the return type and cannot be referenced in the function body",
  "Diagnostic.paramSpecUnknownArg": "ParamSpec does not support more than one argument",
  "Diagnostic.paramSpecUnknownMember": "\"{name}\" is not a known member of ParamSpec",
  "Diagnostic.paramSpecUnknownParam": "\"{name}\" is unknown parameter to ParamSpec",
  "Diagnostic.paramAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to parameter of type \"{paramType}\"",
  "Diagnostic.paramTypeCovariant": "Covariant type variable cannot be used in parameter type",
  "Diagnostic.paramTypeUnknown": "Type of parameter \"{paramName}\" is unknown",
  "Diagnostic.paramTypePartiallyUnknown": "Type of parameter \"{paramName}\" is partially unknown",
  "Diagnostic.parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
  "Diagnostic.patternNeverMatches": "Pattern will never be matched for subject type \"{type}\"",
  "Diagnostic.positionArgAfterNamedArg": "Positional argument cannot appear after keyword arguments",
  "Diagnostic.privateImportFromPyTypedModule": "\"{name}\" is not exported from module \"{module}\"",
  "Diagnostic.positionOnlyAfterArgs": "Position-only argument separator not allowed after \"*\" parameter",
  "Diagnostic.positionOnlyAfterKeywordOnly": "\"/\" parameter must appear before \"*\" parameter",
  "Diagnostic.positionOnlyIncompatible": "Position-only argument separator requires Python 3.8 or newer",
  "Diagnostic.positionOnlyFirstParam": "Position-only argument separator not allowed as first parameter",
  "Diagnostic.privateUsedOutsideOfClass": "\"{name}\" is private and used outside of the class in which it is declared",
  "Diagnostic.privateUsedOutsideOfModule": "\"{name}\" is private and used outside of the module in which it is declared",
  "Diagnostic.propertyOverridden": "\"{name}\" incorrectly overrides property of same name in class \"{className}\"",
  "Diagnostic.propertyStaticMethod": "Static methods not allowed for property getter, setter or deleter",
  "Diagnostic.protectedUsedOutsideOfClass": "\"{name}\" is protected and used outside of the class in which it is declared",
  "Diagnostic.protocolBaseClass": "Protocol class \"{classType}\" cannot derive from non-protocol class \"{baseType}\"",
  "Diagnostic.protocolBaseClassWithTypeArgs": "Type arguments are not allowed with Protocol class when using type parameter syntax",
  "Diagnostic.protocolIllegal": "Use of \"Protocol\" requires Python 3.7 or newer",
  "Diagnostic.protocolMemberNotClassVar": "Protocol class \"{className}\" does not define \"{memberName}\" as a ClassVar",
  "Diagnostic.protocolNotAllowedInTypeArgument": "\"Protocol\" cannot be used as a type argument",
  "Diagnostic.protocolUsedInCall": "Protocol class cannot be used in \"{name}\" call",
  "Diagnostic.protocolVarianceContravariant": "Type variable \"{variable}\" used in generic protocol \"{class}\" should be contravariant",
  "Diagnostic.protocolVarianceCovariant": "Type variable \"{variable}\" used in generic protocol \"{class}\" should be covariant",
  "Diagnostic.protocolVarianceInvariant": "Type variable \"{variable}\" used in generic protocol \"{class}\" should be invariant",
  "Diagnostic.pyrightCommentInvalidDiagnosticBoolValue": "Pyright comment directive must be followed by \"=\" and a value of true or false",
  "Diagnostic.pyrightCommentInvalidDiagnosticSeverityValue": "Pyright comment directive must be followed by \"=\" and a value of true, false, error, warning, information, or none",
  "Diagnostic.pyrightCommentMissingDirective": "Pyright comment must be followed by a directive (basic or strict) or a diagnostic rule",
  "Diagnostic.pyrightCommentNotOnOwnLine": "Pyright comments used to control file-level settings must appear on their own line",
  "Diagnostic.pyrightCommentUnknownDirective": "\"{directive}\" is an unknown directive for pyright comment; expected \"strict\" or \"basic\"",
  "Diagnostic.pyrightCommentUnknownDiagnosticRule": "\"{rule}\" is an unknown diagnostic rule for pyright comment",
  "Diagnostic.pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" is invalid value for pyright comment; expected true, false, error, warning, information, or none",
  "Diagnostic.readOnlyArgCount": "Expected a single type argument after \"ReadOnly\"",
  "Diagnostic.readOnlyNotInTypedDict": "\"ReadOnly\" is not allowed in this context",
  "Diagnostic.relativeImportNotAllowed": "Relative imports cannot be used with \"import .a\" form; use \"from . import a\" instead",
  "Diagnostic.recursiveDefinition": "Type of \"{name}\" could not be determined because it refers to itself",
  "Diagnostic.requiredArgCount": "Expected a single type argument after \"Required\"",
  "Diagnostic.requiredNotInTypedDict": "\"Required\" is not allowed in this context",
  "Diagnostic.returnInAsyncGenerator": "Return statement with value is not allowed in async generator",
  "Diagnostic.returnOutsideFunction": "\"return\" can be used only within a function",
  "Diagnostic.returnMissing": "Function with declared type of \"{returnType}\" must return value on all code paths",
  "Diagnostic.returnTypeContravariant": "Contravariant type variable cannot be used in return type",
  "Diagnostic.returnTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to return type \"{returnType}\"",
  "Diagnostic.returnTypeUnknown": "Return type is unknown",
  "Diagnostic.returnTypePartiallyUnknown": "Return type, \"{returnType}\", is partially unknown",
  "Diagnostic.revealLocalsArgs": "Expected no arguments for \"reveal_locals\" call",
  "Diagnostic.revealLocalsNone": "No locals in this scope",
  "Diagnostic.revealTypeArgs": "Expected a single positional argument for \"reveal_type\" call",
  "Diagnostic.revealTypeExpectedTextArg": "The \"expected_text\" argument for function \"reveal_type\" must be a str literal value",
  "Diagnostic.revealTypeExpectedTextMismatch": "Type text mismatch; expected \"{expected}\" but received \"{received}\"",
  "Diagnostic.revealTypeExpectedTypeMismatch": "Type mismatch; expected \"{expected}\" but received \"{received}\"",
  "Diagnostic.selfTypeContext": "\"Self\" is not valid in this context",
  "Diagnostic.selfTypeWithTypedSelfOrCls": "\"Self\" cannot be used in a function with a `self` or `cls` parameter that has a type annotation other than \"Self\"",
  "Diagnostic.setterGetterTypeMismatch": "Property setter value type is not assignable to the getter return type",
  "Diagnostic.singleOverload": "\"{name}\" is marked as overload, but additional overloads are missing",
  "Diagnostic.slotsAttributeError": "\"{name}\" is not specified in __slots__",
  "Diagnostic.slotsClassVarConflict": "\"{name}\" conflicts with instance variable declared in __slots__",
  "Diagnostic.starPatternInAsPattern": "Star pattern cannot be used with \"as\" target",
  "Diagnostic.starPatternInOrPattern": "Star pattern cannot be ORed within other patterns",
  "Diagnostic.starStarWildcardNotAllowed": "** cannot be used with wildcard \"_\"",
  "Diagnostic.staticClsSelfParam": "Static methods should not take a \"self\" or \"cls\" parameter",
  "Diagnostic.stdlibModuleOverridden": "\"{path}\" is overriding the stdlib module \"{name}\"",
  "Diagnostic.strictTypeGuardReturnType": "Return type of StrictTypeGuard (\"{returnType}\") is not assignable to value parameter type (\"{type}\")",
  "Diagnostic.stringNonAsciiBytes": "Non-ASCII character not allowed in bytes string literal",
  "Diagnostic.stringNotSubscriptable": "String expression cannot be subscripted in type annotation; enclose entire annotation in quotes",
  "Diagnostic.stringUnsupportedEscape": "Unsupported escape sequence in string literal",
  "Diagnostic.stringUnterminated": "String literal is unterminated",
  "Diagnostic.stubFileMissing": "Stub file not found for \"{importName}\"",
  "Diagnostic.stubUsesGetAttr": "Type stub file is incomplete; \"__getattr__\" obscures type errors for module",
  "Diagnostic.sublistParamsIncompatible": "Sublist parameters are not supported in Python 3.x",
  "Diagnostic.superCallArgCount": "Expected no more than two arguments to \"super\" call",
  "Diagnostic.superCallFirstArg": "Expected class type as first argument to \"super\" call but received \"{type}\"",
  "Diagnostic.superCallSecondArg": "Second argument to \"super\" call must be object or class that derives from \"{type}\"",
  "Diagnostic.superCallZeroArgForm": "Zero-argument form of \"super\" call is valid only within a class",
  "Diagnostic.symbolIsUnbound": "\"{name}\" is unbound",
  "Diagnostic.symbolIsUndefined": "\"{name}\" is not defined",
  "Diagnostic.symbolIsPossiblyUnbound": "\"{name}\" is possibly unbound",
  "Diagnostic.symbolOverridden": "\"{name}\" overrides symbol of same name in class \"{className}\"",
  "Diagnostic.totalOrderingMissingMethod": "Class must define one of \"__lt__\", \"__le__\", \"__gt__\", or \"__ge__\" to use total_ordering",
  "Diagnostic.trailingCommaInFromImport": "Trailing comma not allowed without surrounding parentheses",
  "Diagnostic.tryWithoutExcept": "Try statement must have at least one except or finally clause",
  "Diagnostic.tupleAssignmentMismatch": "Expression with type \"{type}\" cannot be assigned to target tuple",
  "Diagnostic.tupleInAnnotation": "Tuple expression not allowed in type annotation",
  "Diagnostic.tupleIndexOutOfRange": "Index {index} is out of range for type {type}",
  "Diagnostic.typeAliasIllegalExpressionForm": "Invalid expression form for type alias definition",
  "Diagnostic.typeAliasIsRecursiveDirect": "Type alias \"{name}\" cannot use itself in its definition",
  "Diagnostic.typeAliasNotInModuleOrClass": "A TypeAlias can be defined only within a module or class scope",
  "Diagnostic.typeAliasRedeclared": "\"{name}\" is declared as a TypeAlias and can be assigned only once",
  "Diagnostic.typeAliasStatementIllegal": "Type alias statement requires Python 3.12 or newer",
  "Diagnostic.typeAliasTypeMustBeAssigned": "TypeAliasType must be assigned to a variable with the same name as the type alias",
  "Diagnostic.typeAliasTypeNameArg": "First argument to TypeAliasType must be a string literal representing the name of the type alias",
  "Diagnostic.typeAliasTypeNameMismatch": "Name of type alias must match the name of the variable to which it is assigned",
  "Diagnostic.typeAliasTypeParamInvalid": "Type parameter list must be a tuple containing only TypeVar, TypeVarTuple, or ParamSpec",
  "Diagnostic.typeArgListExpected": "Expected ParamSpec, ellipsis, or list of types",
  "Diagnostic.typeAnnotationCall": "Illegal type annotation: call expression not allowed",
  "Diagnostic.typeAnnotationVariable": "Illegal type annotation: variable not allowed unless it is a type alias",
  "Diagnostic.typeArgListNotAllowed": "List expression not allowed for this type argument",
  "Diagnostic.typeArgsExpectingNone": "Expected no type arguments for class \"{name}\"",
  "Diagnostic.typeArgsMismatchOne": "Expected one type argument but received {received}",
  "Diagnostic.typeArgsMissingForAlias": "Expected type arguments for generic type alias \"{name}\"",
  "Diagnostic.typeArgsMissingForClass": "Expected type arguments for generic class \"{name}\"",
  "Diagnostic.typeArgsTooFew": "Too few type arguments provided for \"{name}\"; expected {expected} but received {received}",
  "Diagnostic.typeArgsTooMany": "Too many type arguments provided for \"{name}\"; expected {expected} but received {received}",
  "Diagnostic.typeAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to declared type \"{destType}\"",
  "Diagnostic.typeCallNotAllowed": "type() call should not be used in type annotation",
  "Diagnostic.typeCommentDeprecated": "Use of type comments is deprecated; use type annotation instead",
  "Diagnostic.typedDictAccess": "Could not access item in TypedDict",
  "Diagnostic.typedDictBadVar": "TypedDict classes can contain only type annotations",
  "Diagnostic.typedDictBaseClass": "All base classes for TypedDict classes must also be TypedDict classes",
  "Diagnostic.typedDictBoolParam": "Expected \"{name}\" parameter to have a value of True or False",
  "Diagnostic.typedDictDelete": "Could not delete item in TypedDict",
  "Diagnostic.typedDictEmptyName": "Names within a TypedDict cannot be empty",
  "Diagnostic.typedDictEntryName": "Expected string literal for dictionary entry name",
  "Diagnostic.typedDictEntryUnique": "Names within a dictionary must be unique",
  "Diagnostic.typedDictExtraArgs": "Extra TypedDict arguments not supported",
  "Diagnostic.typedDictFieldReadOnlyRedefinition": "TypedDict field \"{name}\" cannot be redefined as read-only",
  "Diagnostic.typedDictFieldTypeRedefinition": "Type of TypedDict field \"{name}\" cannot be redefined",
  "Diagnostic.typedDictFirstArg": "Expected TypedDict class name as first argument",
  "Diagnostic.typedDictSecondArgDict": "Expected dict or keyword parameter as second parameter",
  "Diagnostic.typedDictSecondArgDictEntry": "Expected simple dictionary entry",
  "Diagnostic.typedDictSet": "Could not assign item in TypedDict",
  "Diagnostic.typeExpectedClass": "Expected type expression but received \"{type}\"",
  "Diagnostic.typeGuardArgCount": "Expected a single type argument after \"TypeGuard\"",
  "Diagnostic.typeGuardParamCount": "User-defined type guard functions and methods must have at least one input parameter",
  "Diagnostic.typeNotAwaitable": "\"{type}\" is not awaitable",
  "Diagnostic.typeNotCallable": "\"{expression}\" has type \"{type}\" and is not callable",
  "Diagnostic.typeNotIntantiable": "\"{type}\" cannot be instantiated",
  "Diagnostic.typeNotIterable": "\"{type}\" is not iterable",
  "Diagnostic.typeNotSpecializable": "Could not specialize type \"{type}\"",
  "Diagnostic.typeNotSubscriptable": "Object of type \"{type}\" is not subscriptable",
  "Diagnostic.typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not implement {method}",
  "Diagnostic.typeNotSupportBinaryOperator": "Operator \"{operator}\" not supported for types \"{leftType}\" and \"{rightType}\"",
  "Diagnostic.typeNotSupportBinaryOperatorBidirectional": "Operator \"{operator}\" not supported for types \"{leftType}\" and \"{rightType}\" when expected type is \"{expectedType}\"",
  "Diagnostic.typeNotSupportUnaryOperator": "Operator \"{operator}\" not supported for type \"{type}\"",
  "Diagnostic.typeNotSupportUnaryOperatorBidirectional": "Operator \"{operator}\" not supported for type \"{type}\" when expected type is \"{expectedType}\"",
  "Diagnostic.typeParameterBoundNotAllowed": "Bound or constraint cannot be used with a variadic type parameter or ParamSpec",
  "Diagnostic.typeParameterConstraintTuple": "Type parameter constraint must be a tuple of two or more types",
  "Diagnostic.typeParameterExistingTypeParameter": "Type parameter \"{name}\" is already in use",
  "Diagnostic.typeParametersMissing": "At least one type parameter must be specified",
  "Diagnostic.typeParameterNotDeclared": "Type parameter \"{name}\" is not included in the type parameter list for \"{container}\"",
  "Diagnostic.typePartiallyUnknown": "Type of \"{name}\" is partially unknown",
  "Diagnostic.typeUnknown": "Type of \"{name}\" is unknown",
  "Diagnostic.typeVarAssignedName": "TypeVar must be assigned to a variable named \"{name}\"",
  "Diagnostic.typeVarAssignmentMismatch": "Type \"{type}\" cannot be assigned to type variable \"{name}\"",
  "Diagnostic.typeVarBoundAndConstrained": "TypeVar cannot be both bound and constrained",
  "Diagnostic.typeVarBoundGeneric": "TypeVar bound type cannot be generic",
  "Diagnostic.typeVarConstraintGeneric": "TypeVar constraint type cannot be generic",
  "Diagnostic.typeVarDefaultBoundMismatch": "TypeVar default type must be a subtype of the bound type",
  "Diagnostic.typeVarDefaultConstraintMismatch": "TypeVar default type must be one of the constrained types",
  "Diagnostic.typeVarDefaultIllegal": "Type variable default types require Python 3.13 or newer",
  "Diagnostic.typeVarDefaultInvalidTypeVar": "Type parameter \"{name}\" has a default type that refers to one or more type variables that are out of scope",
  "Diagnostic.typeVarFirstArg": "Expected name of TypeVar as first argument",
  "Diagnostic.typeVarNoMember": "TypeVar \"{type}\" has no member \"{name}\"",
  "Diagnostic.typeVarNotSubscriptable": "TypeVar \"{type}\" is not subscriptable",
  "Diagnostic.typeVarNotUsedByOuterScope": "Type variable \"{name}\" has no meaning in this context",
  "Diagnostic.typeVarPossiblyUnsolvable": "Type variable \"{name}\" may go unsolved if caller supplies no argument for parameter \"{param}\"",
  "Diagnostic.typeVarScopedToReturnType": "Type variable \"{name}\" is scoped to a callable within the return type and cannot be referenced in the function body",
  "Diagnostic.typeVarSingleConstraint": "TypeVar must have at least two constrained types",
  "Diagnostic.typeVarsNotInGenericOrProtocol": "Generic[] or Protocol[] must include all type variables",
  "Diagnostic.typeVarTupleContext": "TypeVarTuple not allowed in this context",
  "Diagnostic.typeVarTupleDefaultNotUnpacked": "TypeVarTuple default type must be an unpacked tuple or TypeVarTuple",
  "Diagnostic.typeVarTupleMustBeUnpacked": "Unpack operator is required for TypeVarTuple value",
  "Diagnostic.typeVarTupleUnknownParam": "\"{name}\" is unknown parameter to TypeVarTuple",
  "Diagnostic.typeVarUnknownParam": "\"{name}\" is unknown parameter to TypeVar",
  "Diagnostic.typeVarUsedByOuterScope": "TypeVar \"{name}\" is already in use by an outer scope",
  "Diagnostic.typeVarUsedOnlyOnce": "TypeVar \"{name}\" appears only once in generic function signature",
  "Diagnostic.typeVarVariance": "TypeVar cannot be both covariant and contravariant",
  "Diagnostic.typeVarWithoutDefault": "\"{name}\" cannot appear after \"{other}\" in type parameter list because it has no default type",
  "Diagnostic.unaccessedClass": "Class \"{name}\" is not accessed",
  "Diagnostic.unaccessedFunction": "Function \"{name}\" is not accessed",
  "Diagnostic.unaccessedImport": "Import \"{name}\" is not accessed",
  "Diagnostic.unaccessedSymbol": "\"{name}\" is not accessed",
  "Diagnostic.unaccessedVariable": "Variable \"{name}\" is not accessed",
  "Diagnostic.unannotatedFunctionSkipped": "Analysis of function \"{name}\" is skipped because it is unannotated",
  "Diagnostic.unexpectedAsyncToken": "Expected \"def\", \"with\" or \"for\" to follow \"async\"",
  "Diagnostic.unexpectedExprToken": "Unexpected token at end of expression",
  "Diagnostic.unexpectedIndent": "Unexpected indentation",
  "Diagnostic.unexpectedUnindent": "Unindent not expected",
  "Diagnostic.unhashableDictKey": "Dictionary key must be hashable",
  "Diagnostic.unhashableSetEntry": "Set entry must be hashable",
  "Diagnostic.unionForwardReferenceNotAllowed": "Union syntax cannot be used with string operand; use quotes around entire expression",
  "Diagnostic.unionSyntaxIllegal": "Alternative syntax for unions requires Python 3.10 or newer",
  "Diagnostic.unionTypeArgCount": "Union requires two or more type arguments",
  "Diagnostic.uninitializedAbstractVariables": "Variables defined in abstract base class are not initialized in final class \"{classType}\"",
  "Diagnostic.uninitializedInstanceVariable": "Instance variable \"{name}\" is not initialized in the class body or __init__ method",
  "Diagnostic.unmatchedEndregionComment": "#endregion is missing corresponding #region",
  "Diagnostic.unmatchedRegionComment": "#region is missing corresponding #endregion",
  "Diagnostic.unnecessaryCast": "Unnecessary \"cast\" call; type is already \"{type}\"",
  "Diagnostic.unnecessaryIsInstanceAlways": "Unnecessary isinstance call; \"{testType}\" is always an instance of \"{classType}\"",
  "Diagnostic.unnecessaryIsSubclassAlways": "Unnecessary issubclass call; \"{testType}\" is always a subclass of \"{classType}\"",
  "Diagnostic.unnecessaryPyrightIgnore": "Unnecessary \"# pyright: ignore\" comment",
  "Diagnostic.unnecessaryPyrightIgnoreRule": "Unnecessary \"# pyright: ignore\" rule: \"{name}\"",
  "Diagnostic.unnecessaryTypeIgnore": "Unnecessary \"# type: ignore\" comment",
  "Diagnostic.unpackArgCount": "Expected a single type argument after \"Unpack\"",
  "Diagnostic.unpackedArgInTypeArgument": "Unpacked arguments cannot be used in type argument lists",
  "Diagnostic.unpackedArgWithVariadicParam": "Unpacked argument cannot be used for TypeVarTuple parameter",
  "Diagnostic.unpackedDictArgumentNotMapping": "Argument expression after ** must be a mapping with a \"str\" key type",
  "Diagnostic.unpackedSubscriptIllegal": "Unpack operator in subscript requires Python 3.11 or newer",
  "Diagnostic.unpackedTypedDictArgument": "Unable to match unpacked TypedDict argument to parameters",
  "Diagnostic.unpackedTypeVarTupleExpected": "Expected unpacked TypeVarTuple; use Unpack[{name1}] or *{name2}",
  "Diagnostic.unpackExpectedTypedDict": "Expected TypedDict type argument for Unpack",
  "Diagnostic.unpackExpectedTypeVarTuple": "Expected TypeVarTuple or Tuple as type argument for Unpack",
  "Diagnostic.unpackIllegalInComprehension": "Unpack operation not allowed in comprehension",
  "Diagnostic.unpackInAnnotation": "Unpack operator not allowed in type annotation",
  "Diagnostic.unpackInDict": "Unpack operation not allowed in dictionaries",
  "Diagnostic.unpackInSet": "Unpack operator not allowed within a set",
  "Diagnostic.unpackNotAllowed": "Unpack not allowed in this context",
  "Diagnostic.unpackOperatorNotAllowed": "Unpack operation not allowed in this context",
  "Diagnostic.unpackTuplesIllegal": "Unpack operation not allowed in tuples prior to Python 3.8",
  "Diagnostic.unreachableCode": "Code is unreachable",
  "Diagnostic.unreachableExcept": "Except clause is unreachable because exception is already handled",
  "Diagnostic.unsupportedDunderAllOperation": "Operation on \"__all__\" is not supported, so exported symbol list may be incorrect",
  "Diagnostic.unusedCallResult": "Result of call expression is of type \"{type}\" and is not used; assign to variable \"_\" if this is intentional",
  "Diagnostic.unusedCoroutine": "Result of async function call is not used; use \"await\" or assign result to variable",
  "Diagnostic.unusedExpression": "Expression value is unused",
  "Diagnostic.varAnnotationIllegal": "Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions",
  "Diagnostic.variableFinalOverride": "Variable \"{name}\" is marked Final and overrides non-Final variable of same name in class \"{className}\"",
  "Diagnostic.variadicTypeArgsTooMany": "Type argument list can have at most one unpacked TypeVarTuple or Tuple",
  "Diagnostic.variadicTypeParamTooManyAlias": "Type alias can have at most one TypeVarTuple type parameter but received multiple ({names})",
  "Diagnostic.variadicTypeParamTooManyClass": "Generic class can have at most one TypeVarTuple type parameter but received multiple ({names})",
  "Diagnostic.walrusIllegal": "Operator \":=\" requires Python 3.8 or newer",
  "Diagnostic.walrusNotAllowed": "Operator \":=\" not allowed in this context without surrounding parentheses",
  "Diagnostic.wildcardInFunction": "Wildcard import not allowed within a class or function",
  "Diagnostic.wildcardPatternTypeUnknown": "Type captured by wildcard pattern is unknown",
  "Diagnostic.wildcardPatternTypePartiallyUnknown": "Type captured by wildcard pattern is partially unknown",
  "Diagnostic.wildcardLibraryImport": "Wildcard import from a library not allowed",
  "Diagnostic.yieldFromIllegal": "Use of \"yield from\" requires Python 3.3 or newer",
  "Diagnostic.yieldFromOutsideAsync": "\"yield from\" not allowed in an async function",
  "Diagnostic.yieldOutsideFunction": "\"yield\" not allowed outside of a function or lambda",
  "Diagnostic.yieldTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to yield type \"{yieldType}\"",
  "Diagnostic.yieldWithinListCompr": "\"yield\" not allowed inside a list comprehension",
  "Diagnostic.zeroCaseStatementsFound": "Match statement must include at least one case statement",
  "Diagnostic.zeroLengthTupleNotAllowed": "Zero-length tuple not allowed in this context",
  "DiagnosticAddendum.argParam": "Argument corresponds to parameter \"{paramName}\"",
  "DiagnosticAddendum.argParamFunction": "Argument corresponds to parameter \"{paramName}\" in function \"{functionName}\"",
  "DiagnosticAddendum.argsParamMissing": "Parameter \"*{paramName}\" has no corresponding parameter",
  "DiagnosticAddendum.argsPositionOnly": "Position-only parameter mismatch; expected {expected} but received {received}",
  "DiagnosticAddendum.argumentType": "Argument type is \"{type}\"",
  "DiagnosticAddendum.argumentTypes": "Argument types: ({types})",
  "DiagnosticAddendum.assignToNone": "Type cannot be assigned to type \"None\"",
  "DiagnosticAddendum.asyncHelp": "Did you mean \"async with\"?",
  "DiagnosticAddendum.baseClassOverriddenType": "Base class \"{baseClass}\" provides type \"{type}\", which is overridden",
  "DiagnosticAddendum.baseClassOverridesType": "Base class \"{baseClass}\" overrides with type \"{type}\"",
  "DiagnosticAddendum.conditionalRequiresBool": "Method __bool__ for type \"{operandType}\" returns type \"{boolReturnType}\" rather than \"bool\"",
  "DiagnosticAddendum.dataClassFieldLocation": "Field declaration",
  "DiagnosticAddendum.dataClassFrozen": "\"{name}\" is frozen",
  "DiagnosticAddendum.finalMethod": "Final method",
  "DiagnosticAddendum.keyNotRequired": "\"{name}\" is not a required key in \"{type}\", so access may result in runtime exception",
  "DiagnosticAddendum.keyReadOnly": "\"{name}\" is a read-only key in \"{type}\"",
  "DiagnosticAddendum.keyRequiredDeleted": "\"{name}\" is a required key and cannot be deleted",
  "DiagnosticAddendum.keyUndefined": "\"{name}\" is not a defined key in \"{type}\"",
  "DiagnosticAddendum.functionParamDefaultMissing": "Parameter \"{name}\" is missing default argument",
  "DiagnosticAddendum.functionParamName": "Parameter name mismatch: \"{destName}\" versus \"{srcName}\"",
  "DiagnosticAddendum.functionReturnTypeMismatch": "Function return type \"{sourceType}\" is incompatible with type \"{destType}\"",
  "DiagnosticAddendum.functionTooFewParams": "Function accepts too few positional parameters; expected {expected} but received {received}",
  "DiagnosticAddendum.functionTooManyParams": "Function accepts too many positional parameters; expected {expected} but received {received}",
  "DiagnosticAddendum.incompatibleGetter": "Property getter method is incompatible",
  "DiagnosticAddendum.incompatibleSetter": "Property setter method is incompatible",
  "DiagnosticAddendum.initMethodLocation": "The __init__ method is defined in class \"{type}\"",
  "DiagnosticAddendum.incompatibleDeleter": "Property deleter method is incompatible",
  "DiagnosticAddendum.initMethodSignature": "Signature of __init__ is \"{type}\"",
  "DiagnosticAddendum.kwargsParamMissing": "Parameter \"**{paramName}\" has no corresponding parameter",
  "DiagnosticAddendum.listAssignmentMismatch": "Type \"{type}\" is incompatible with target list",
  "DiagnosticAddendum.literalAssignmentMismatch": "\"{sourceType}\" cannot be assigned to type \"{destType}\"",
  "DiagnosticAddendum.matchIsNotExhaustiveType": "Unhandled type: \"{type}\"",
  "DiagnosticAddendum.matchIsNotExhaustiveHint": "If exhaustive handling is not intended, add \"case _: pass\"",
  "DiagnosticAddendum.memberSetClassVar": "Member \"{name}\" cannot be assigned through a class instance because it is a ClassVar",
  "DiagnosticAddendum.memberAssignment": "Expression of type \"{type}\" cannot be assigned to member \"{name}\" of class \"{classType}\"",
  "DiagnosticAddendum.memberIsAbstract": "\"{type}.{name}\" is abstract",
  "DiagnosticAddendum.memberIsAbstractMore": "and {count} more...",
  "DiagnosticAddendum.memberIsFinalInProtocol": "\"{name}\" is marked Final in protocol",
  "DiagnosticAddendum.memberIsInitVar": "Member \"{name}\" is an init-only field",
  "DiagnosticAddendum.memberIsInvariant": "\"{name}\" is invariant because it is mutable",
  "DiagnosticAddendum.memberIsNotFinalInProtocol": "\"{name}\" is not marked Final in protocol",
  "DiagnosticAddendum.memberTypeMismatch": "\"{name}\" is an incompatible type",
  "DiagnosticAddendum.memberUnknown": "Member \"{name}\" is unknown",
  "DiagnosticAddendum.missingProtocolMember": "Member \"{name}\" is declared in protocol class \"{classType}\"",
  "DiagnosticAddendum.missingGetter": "Property getter method is missing",
  "DiagnosticAddendum.missingSetter": "Property setter method is missing",
  "DiagnosticAddendum.missingDeleter": "Property deleter method is missing",
  "DiagnosticAddendum.namedParamMissingInDest": "Keyword parameter \"{name}\" is missing in destination",
  "DiagnosticAddendum.namedParamMissingInSource": "Keyword parameter \"{name}\" is missing in source",
  "DiagnosticAddendum.namedParamTypeMismatch": "Keyword parameter \"{name}\" of type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
  "DiagnosticAddendum.newMethodLocation": "The __new__ method is defined in class \"{type}\"",
  "DiagnosticAddendum.newMethodSignature": "Signature of __new__ is \"{type}\"",
  "DiagnosticAddendum.noOverloadAssignable": "No overloaded function matches type \"{type}\"",
  "DiagnosticAddendum.orPatternMissingName": "Missing names: {name}",
  "DiagnosticAddendum.overloadSignature": "Overload signature is defined here",
  "DiagnosticAddendum.overloadNotAssignable": "One or more overloads of \"{name}\" is not assignable",
  "DiagnosticAddendum.overloadWithImplementation": "The body of a function overload should be \"...\"",
  "DiagnosticAddendum.overriddenMethod": "Overridden method",
  "DiagnosticAddendum.overriddenSymbol": "Overridden symbol",
  "DiagnosticAddendum.overrideNoOverloadMatches": "No overload signature in override is compatible with base method",
  "DiagnosticAddendum.overrideNotClassMethod": "Base method is declared as a classmethod but override is not",
  "DiagnosticAddendum.overrideNotInstanceMethod": "Base method is declared as an instance method but override is not",
  "DiagnosticAddendum.overrideNotStaticMethod": "Base method is declared as a staticmethod but override is not",
  "DiagnosticAddendum.overrideParamKeywordNoDefault": "Keyword parameter \"{name}\" mismatch: base parameter has default argument value, override parameter does not",
  "DiagnosticAddendum.overrideParamKeywordType": "Keyword parameter \"{name}\" type mismatch: base parameter is type \"{baseType}\", override parameter is type \"{overrideType}\"",
  "DiagnosticAddendum.overrideParamName": "Parameter {index} name mismatch: base parameter is named \"{baseName}\", override parameter is named \"{overrideName}\"",
  "DiagnosticAddendum.overrideParamNameExtra": "Parameter \"{name}\" is missing in base",
  "DiagnosticAddendum.overrideParamNameMissing": "Parameter \"{name}\" is missing in override",
  "DiagnosticAddendum.overrideParamNamePositionOnly": "Parameter {index} name mismatch: base parameter is named \"{baseName}\", override parameter is position-only\"",
  "DiagnosticAddendum.overrideParamNoDefault": "Parameter {index} mismatch: base parameter has default argument value, override parameter does not",
  "DiagnosticAddendum.overrideParamType": "Parameter {index} type mismatch: base parameter is type \"{baseType}\", override parameter is type \"{overrideType}\"",
  "DiagnosticAddendum.overridePositionalParamCount": "Positional parameter count mismatch; base method has {baseCount}, but override has {overrideCount}",
  "DiagnosticAddendum.overrideReturnType": "Return type mismatch: base method returns type \"{baseType}\", override returns type \"{overrideType}\"",
  "DiagnosticAddendum.overrideType": "Base class defines type as \"{type}\"",
  "DiagnosticAddendum.paramAssignment": "Parameter {index}: type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
  "DiagnosticAddendum.paramSpecMissingInOverride": "ParamSpec parameters are missing in override method",
  "DiagnosticAddendum.paramType": "Parameter type is \"{paramType}\"",
  "DiagnosticAddendum.privateImportFromPyTypedSource": "Import from \"{module}\" instead",
  "DiagnosticAddendum.propertyAccessFromProtocolClass": "A property defined within a protocol class cannot be accessed as a class variable",
  "DiagnosticAddendum.propertyMethodIncompatible": "Property method \"{name}\" is incompatible",
  "DiagnosticAddendum.propertyMethodMissing": "Property method \"{name}\" is missing in override",
  "DiagnosticAddendum.propertyMissingDeleter": "Property \"{name}\" has no defined deleter",
  "DiagnosticAddendum.propertyMissingSetter": "Property \"{name}\" has no defined setter",
  "DiagnosticAddendum.protocolIncompatible": "\"{sourceType}\" is incompatible with protocol \"{destType}\"",
  "DiagnosticAddendum.protocolMemberClassVar": "\"{name}\" is not a class variable",
  "DiagnosticAddendum.protocolMemberMissing": "\"{name}\" is not present",
  "DiagnosticAddendum.protocolSourceIsNotConcrete": "\"{sourceType}\" is not a concrete class type and cannot be assigned to type \"{destType}\"",
  "DiagnosticAddendum.pyrightCommentIgnoreTip": "Use \"# pyright: ignore[<diagnostic rules>] to suppress diagnostics for a single line",
  "DiagnosticAddendum.readOnlyAttribute": "Attribute \"{name}\" is read-only",
  "DiagnosticAddendum.seeDeclaration": "See declaration",
  "DiagnosticAddendum.seeClassDeclaration": "See class declaration",
  "DiagnosticAddendum.seeFunctionDeclaration": "See function declaration",
  "DiagnosticAddendum.seeMethodDeclaration": "See method declaration",
  "DiagnosticAddendum.seeParameterDeclaration": "See parameter declaration",
  "DiagnosticAddendum.seeTypeAliasDeclaration": "See type alias declaration",
  "DiagnosticAddendum.seeVariableDeclaration": "See variable declaration",
  "DiagnosticAddendum.tupleEntryTypeMismatch": "Tuple entry {entry} is incorrect type",
  "DiagnosticAddendum.tupleAssignmentMismatch": "Type \"{type}\" is incompatible with target tuple",
  "DiagnosticAddendum.tupleSizeMismatch": "Element size mismatch; expected {expected} but received {received}",
  "DiagnosticAddendum.typeAssignmentMismatch": "Type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
  "DiagnosticAddendum.typeBound": "Type \"{sourceType}\" is incompatible with bound type \"{destType}\" for type variable \"{name}\"",
  "DiagnosticAddendum.typeConstrainedTypeVar": "Type \"{type}\" is incompatible with constrained type variable \"{name}\"",
  "DiagnosticAddendum.typedDictFieldMissing": "\"{name}\" is missing from \"{type}\"",
  "DiagnosticAddendum.typedDictFieldNotReadOnly": "\"{name}\" is not read-only in \"{type}\"",
  "DiagnosticAddendum.typedDictFieldNotRequired": "\"{name}\" is not required in \"{type}\"",
  "DiagnosticAddendum.typedDictFieldRequired": "\"{name}\" is required in \"{type}\"",
  "DiagnosticAddendum.typedDictFieldTypeMismatch": "Type \"{type}\" is not assignable to field \"{name}\"",
  "DiagnosticAddendum.typedDictFieldTypeRedefinition": "Type in parent class is \"{parentType}\" and type in child class is \"{childType}\"",
  "DiagnosticAddendum.typedDictFieldUndefined": "\"{name}\" is an undefined field in type \"{type}\"",
  "DiagnosticAddendum.typedDictFinalMismatch": "\"{sourceType}\" is incompatible with \"{destType}\" because of a @final mismatch",
  "DiagnosticAddendum.typeIncompatible": "\"{sourceType}\" is incompatible with \"{destType}\"",
  "DiagnosticAddendum.typeNotCallable": "Type \"{type}\" is not callable",
  "DiagnosticAddendum.typeNotClass": "\"{type}\" is not a class",
  "DiagnosticAddendum.typeParamSpec": "Type \"{type}\" is incompatible with ParamSpec \"{name}\"",
  "DiagnosticAddendum.typeNotStringLiteral": "\"{type}\" is not a string literal",
  "DiagnosticAddendum.typeOfSymbol": "Type of \"{name}\" is \"{type}\"",
  "DiagnosticAddendum.typeUnsupported": "Type \"{type}\" is unsupported",
  "DiagnosticAddendum.typeVarDefaultOutOfScope": "Type variable \"{name}\" is not in scope",
  "DiagnosticAddendum.typeVarIsContravariant": "TypeVar \"{name}\" is contravariant",
  "DiagnosticAddendum.typeVarIsCovariant": "TypeVar \"{name}\" is covariant",
  "DiagnosticAddendum.typeVarIsInvariant": "TypeVar \"{name}\" is invariant",
  "DiagnosticAddendum.typeVarNotAllowed": "TypeVar or generic type with type arguments not allowed",
  "DiagnosticAddendum.typeVarUnsolvableRemedy": "Provide an overload that specifies the return type when the argument is not supplied",
  "DiagnosticAddendum.typeVarsMissing": "Missing type variables: {names}",
  "DiagnosticAddendum.typeVarTupleRequiresKnownLength": "TypeVarTuple cannot be bound to a tuple of unknown length",
  "DiagnosticAddendum.unhashableType": "Type \"{type}\" is not hashable",
  "DiagnosticAddendum.uninitializedAbstractVariable": "Instance variable \"{name}\" is defined in abstract base class \"{classType}\" but not initialized",
  "DiagnosticAddendum.unreachableExcept": "\"{exceptionType}\" is a subclass of \"{parentType}\"",
  "DiagnosticAddendum.useDictInstead": "Use Dict[T1, T2] to indicate a dictionary type",
  "DiagnosticAddendum.useListInstead": "Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type",
  "DiagnosticAddendum.useTupleInstead": "Use Tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type",
  "DiagnosticAddendum.useTypeInstead": "Use Type[T] instead",
  "DiagnosticAddendum.varianceMismatchForClass": "Variance of type argument \"{typeVarName}\" is incompatible with base class \"{className}\"",
  "DiagnosticAddendum.varianceMismatchForTypeAlias": "Variance of type argument \"{typeVarName}\" is incompatible with \"{typeAliasParam}\"",
  "CodeAction.addOptionalToAnnotation": "Add \"Optional\" to Type Annotation",
  "CodeAction.createTypeStub": "Create Type Stub",
  "CodeAction.createTypeStubFor": "Create Type Stub For \"{moduleName}\"",
  "CodeAction.executingCommand": "Executing command",
  "CodeAction.filesToAnalyzeOne": "1 file to analyze",
  "CodeAction.filesToAnalyzeCount": "{count} files to analyze",
  "CodeAction.findingReferences": "Finding references",
  "CodeAction.organizeImports": "Organize Imports",
  "CodeAction.renameShadowedFile": "Rename \"{oldFile}\" to \"{newFile}\""
}